// This is your Prisma schema file for ByteInbox API
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id              Int        @id @default(autoincrement())
  email           String     @unique
  name            String?
  firstName       String?    @map("first_name")
  lastName        String?    @map("last_name")
  photoUrl        String?    @map("photo_url")
  timezone        String     @default("UTC")
  language        String     @default("en")
  status          UserStatus @default(ACTIVE)
  type            UserType   @default(CUSTOMER)
  emailVerifiedAt DateTime?  @map("email_verified_at") // When email was verified (null = not verified)
  totpEnabled     Boolean    @default(false) @map("totp_enabled")
  totpSecret      String?    @map("totp_secret") // TOTP secret (encrypted)
  createdAt       DateTime   @default(now()) @map("created_at")
  updatedAt       DateTime   @updatedAt @map("updated_at")

  // Relations
  domains                 Domain[]
  emails                  Email[]
  templates               Template[]
  webhooks                Webhook[]
  apiKeys                 ApiKey[]
  broadcasts              Broadcast[]
  contacts                Contact[]
  audiences               Audience[]
  localAuthAccount        LocalAuthAccount? // Password-based auth (optional)
  oauthAccounts           OAuthAccount[] // OAuth providers (google, github, etc.)
  sessions                Session[]
  teamMemberships         TeamMember[]
  backupCodes             MfaBackupCode[]
  mfaVerificationSessions MfaVerificationSession[]
  verificationRequests    VerificationRequest[]
  blacklistsCreated       Blacklist[]
  notifications           Notification[]

  @@map("users")
}

model OAuthAccount {
  id             Int           @id @default(autoincrement())
  userId         Int           @map("user_id")
  provider       OAuthProvider // google, github etc.
  providerUserId String        @map("provider_user_id") // Unique ID from OAuth provider
  type           String        @default("oauth") // oauth, oidc
  accessToken    String?       @map("access_token") @db.Text // Encrypt at rest
  refreshToken   String?       @map("refresh_token") @db.Text // Encrypt at rest
  expiresAt      Int?          @map("expires_at") // Unix timestamp
  tokenType      String?       @map("token_type")
  scope          String?
  idToken        String?       @map("id_token") @db.Text
  sessionState   String?       @map("session_state")
  metadata       Json? // Provider user data (name, profile pic, etc.)
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@map("oauth_accounts")
}

model LocalAuthAccount {
  id           Int      @id @default(autoincrement())
  userId       Int      @unique @map("user_id") // One password per user
  passwordHash String   @map("password_hash") // Hashed password (bcrypt/argon2) - Encrypt at rest
  passwordSalt String?  @map("password_salt") // Optional explicit salt
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("local_auth_accounts")
}

model Session {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  refreshToken String   @map("refresh_token") // Hashed refresh token - Encrypt at rest
  userAgent    String?  @map("user_agent")
  ipAddress    String?  @map("ip_address")
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationRequest {
  id        Int                     @id @default(autoincrement())
  userId    Int                     @map("user_id")
  email     String
  token     String                  @unique
  type      VerificationRequestType
  expiresAt DateTime                @map("expires_at")
  createdAt DateTime                @default(now()) @map("created_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([email, token])
  @@map("verification_requests")
}

model MfaBackupCode {
  id        Int       @id @default(autoincrement())
  userId    Int       @map("user_id")
  code      String // Hashed backup code
  used      Boolean   @default(false)
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("mfa_backup_codes")
}

model MfaVerificationSession {
  id           Int                          @id @default(autoincrement())
  sessionToken String                       @unique @map("session_token")
  userId       Int                          @map("user_id")
  email        String
  mfaMethod    MfaMethod                    @map("mfa_method")
  status       MfaVerificationSessionStatus @default(pending)
  expiresAt    DateTime                     @map("expires_at")
  createdAt    DateTime                     @default(now()) @map("created_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("mfa_verification_sessions")
}

model FailedLoginAttempt {
  id        Int      @id @default(autoincrement())
  email     String // Email attempted (user may not exist)
  ipAddress String   @map("ip_address")
  userAgent String?  @map("user_agent")
  reason    String // invalid_password, user_not_found, account_locked, mfa_failed
  createdAt DateTime @default(now()) @map("created_at")

  @@index([email, createdAt]) // For rate limiting
  @@index([ipAddress, createdAt]) // For IP-based blocking
  @@map("failed_login_attempts")
}

model Blacklist {
  id        Int           @id @default(autoincrement())
  type      BlacklistType
  value     String // IP address, email, domain, userId
  reason    String? // Why this was blacklisted
  createdAt DateTime      @default(now()) @map("created_at")
  createdBy Int?          @map("created_by")

  CreatedBy User? @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  @@unique([type, value])
  @@index([type, value]) // Fast lookups
  @@map("blacklists")
}

// ============================================
// TEAMS & WORKSPACES
// ============================================

model Team {
  id        Int      @id @default(autoincrement())
  reference String   @unique @default(cuid()) @map("reference") // UUID-like reference for API usage
  name      String
  slug      String // Non-unique slug for display purposes
  image     String? // Team logo/avatar URL
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  members         TeamMember[]
  invitations     TeamInvitation[]
  domains         Domain[]
  emails          Email[]
  templates       Template[]
  webhooks        Webhook[]
  apiKeys         ApiKey[]
  broadcasts      Broadcast[]
  contacts        Contact[]
  audiences       Audience[]
  subscriptions   Subscription[]
  apiRequestLogs  ApiRequestLog[]
  apiUsageMetrics ApiUsageMetric[]
  emailMetrics    EmailMetrics[]
  notifications   Notification[]

  @@map("teams")
}

model TeamMember {
  id        Int            @id @default(autoincrement())
  teamId    Int            @map("team_id")
  userId    Int            @map("user_id")
  role      TeamMemberRole @default(member)
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  Team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

model TeamInvitation {
  id         Int                  @id @default(autoincrement())
  teamId     Int                  @map("team_id")
  email      String
  role       String               @default("member") // admin, member, viewer
  token      String               @unique
  invitedBy  String               @map("invited_by") // userId who sent the invitation
  status     TeamInvitationStatus @default(pending)
  expiresAt  DateTime             @map("expires_at")
  createdAt  DateTime             @default(now()) @map("created_at")
  updatedAt  DateTime             @updatedAt @map("updated_at")
  acceptedAt DateTime?            @map("accepted_at")

  Team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, email])
  @@map("team_invitations")
}

// ============================================
// PLANS & SUBSCRIPTIONS
// ============================================

model Plan {
  id              Int             @id @default(autoincrement())
  name            String          @unique // "free", "starter", "pro", "business", "enterprise"
  slug            String          @unique // URL-friendly identifier: "free", "pro-monthly", etc.
  displayName     String          @map("display_name") // "Free Plan", "Pro Plan", "Enterprise"
  description     String?
  price           Decimal         @db.Decimal(10, 2) // Monthly price
  yearlyPrice     Decimal?        @map("yearly_price") @db.Decimal(10, 2) // Yearly price (if applicable)
  currency        String          @default("USD")
  billingInterval BillingInterval @map("billing_interval") // MONTHLY, YEARLY

  // Feature limits
  maxDomains        Int @map("max_domains")
  maxEmailsPerMonth Int @map("max_emails_per_month")
  maxTeamMembers    Int @map("max_team_members")
  maxTemplates      Int @map("max_templates")
  maxWebhooks       Int @map("max_webhooks")
  maxContacts       Int @map("max_contacts")
  maxAudiences      Int @map("max_audiences")
  maxBroadcasts     Int @map("max_broadcasts")

  // Feature flags
  customDomain      Boolean @default(false) @map("custom_domain")
  advancedAnalytics Boolean @default(false) @map("advanced_analytics")
  prioritySupport   Boolean @default(false) @map("priority_support")
  apiAccess         Boolean @default(false) @map("api_access")
  webhookSupport    Boolean @default(false) @map("webhook_support")
  teamCollaboration Boolean @default(false) @map("team_collaboration")

  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  subscriptions Subscription[]

  @@map("plans")
}

model Subscription {
  id     Int                @id @default(autoincrement())
  teamId Int                @map("team_id")
  planId Int                @map("plan_id")
  status SubscriptionStatus @default(ACTIVE)

  // Billing details
  stripeCustomerId      String? @map("stripe_customer_id")
  stripeSubscriptionId  String? @unique @map("stripe_subscription_id")
  stripePaymentMethodId String? @map("stripe_payment_method_id")

  // Subscription period
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  cancelAtPeriodEnd  Boolean   @default(false) @map("cancel_at_period_end")
  canceledAt         DateTime? @map("canceled_at")

  // Trial information
  trialStart DateTime? @map("trial_start")
  trialEnd   DateTime? @map("trial_end")

  // Usage tracking
  emailsSentThisMonth Int      @default(0) @map("emails_sent_this_month")
  lastUsageReset      DateTime @default(now()) @map("last_usage_reset")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  Team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  Plan Plan @relation(fields: [planId], references: [id])

  @@map("subscriptions")
}

// ============================================
// DOMAINS
// ============================================

model Domain {
  id            Int          @id @default(autoincrement())
  name          String // Domain name - multiple teams can use the same domain
  createdBy     Int?         @map("created_by") // User who created this domain
  teamId        Int          @map("team_id") // Team that owns this domain (personal or shared)
  status        DomainStatus @default(pending_dns)
  region        String? // us-east-1, eu-west-1, etc.
  clickTracking Boolean      @default(true) @map("click_tracking")
  openTracking  Boolean      @default(true) @map("open_tracking")
  tlsMode       String       @default("enforced") @map("tls_mode") // enforced, opportunistic, disabled

  // DKIM Configuration (per-domain keys)
  dkimSelector   String? @map("dkim_selector") // Unique DKIM selector for this domain
  dkimPublicKey  String? @map("dkim_public_key") // Base64 encoded DKIM public key
  dkimPrivateKey String? @map("dkim_private_key") // Base64 encoded DKIM private key (encrypted)

  // AWS Registration tracking
  awsRegisteredAt DateTime? @map("aws_registered_at") // When domain was registered with AWS SES

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  Creator          User?                    @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team             Team                     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  dnsRecords       DnsRecord[]
  emails           Email[]
  ownershipHistory DomainOwnershipHistory[]

  @@map("domains")
}

model DnsRecord {
  id            Int          @id @default(autoincrement())
  domainId      Int          @map("domain_id")
  type          String // dkim, spf, dmarc, mx, tracking
  name          String
  recordType    String       @map("record_type") // TXT, MX, CNAME
  value         String
  status        DomainStatus @default(pending_dns)
  priority      Int? // for MX records
  lastCheckedAt DateTime?    @map("last_checked_at") // When this DNS record was last verified

  Domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@map("dns_records")
}

// Domain Ownership History - tracks domain transfers between teams
model DomainOwnershipHistory {
  id             Int      @id @default(autoincrement())
  domainId       Int      @map("domain_id")
  domainName     String   @map("domain_name") // Denormalized for historical records
  previousTeamId Int?     @map("previous_team_id") // Team that previously owned the domain
  newTeamId      Int      @map("new_team_id") // Team that now owns the domain
  transferReason String?  @map("transfer_reason") // Why the domain was transferred (dns_verification, manual, etc.)
  metadata       Json? // Additional transfer metadata (DKIM keys changed, AWS status, etc.)
  createdAt      DateTime @default(now()) @map("created_at")

  Domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@index([domainId])
  @@index([previousTeamId])
  @@index([newTeamId])
  @@map("domain_ownership_history")
}

// ============================================
// NOTIFICATIONS
// ============================================

// Notifications table - stores all system notifications for users/teams
model Notification {
  id        Int                  @id @default(autoincrement())
  userId    Int?                 @map("user_id") // User to notify (if user-specific)
  teamId    Int?                 @map("team_id") // Team to notify (if team-wide)
  type      NotificationType // domain_transfer, domain_verified, domain_failed, etc.
  title     String // Notification title
  message   String               @db.Text // Notification message body
  severity  NotificationSeverity @default(info) // info, warning, error, success
  read      Boolean              @default(false) // Whether notification has been read
  readAt    DateTime?            @map("read_at") // When notification was read
  metadata  Json? // Additional context (domain name, domain ID, etc.)
  createdAt DateTime             @default(now()) @map("created_at")

  User User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  Team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([teamId, read])
  @@index([createdAt])
  @@map("notifications")
}

// ============================================
// EMAILS
// ============================================

model Email {
  id        Int         @id @default(autoincrement())
  reference String?     @unique @default(cuid()) @map("reference") // Public-facing UUID reference for API
  createdBy Int?        @map("created_by") // User who created/sent this email
  teamId    Int         @map("team_id") // Team that owns this email (personal or shared)
  domainId  Int?        @map("domain_id")
  apiKeyId  Int?        @map("api_key_id") // API key used to send the email
  from      String
  to        String[]    @default([]) // Array of TO recipient email addresses
  cc        String[]    @default([]) // Array of CC recipient email addresses
  bcc       String[]    @default([]) // Array of BCC recipient email addresses
  replyTo   String[]    @default([]) @map("reply_to")
  subject   String
  text      String?
  html      String?
  sentAt    DateTime?   @map("sent_at") // When all recipients were sent
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  // Relations
  Creator     User?             @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team        Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  Domain      Domain?           @relation(fields: [domainId], references: [id], onDelete: SetNull)
  ApiKey      ApiKey?           @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)
  attachments Attachment[]
  recipients  EmailRecipient[] // Per-recipient tracking for TO, CC, and BCC

  @@map("emails")
}

model EmailRecipient {
  id          Int         @id @default(autoincrement())
  emailId     Int         @map("email_id")
  recipient   String // Recipient email address (from TO, CC, or BCC)
  status      EmailStatus @default(queued)
  messageId   String?     @map("message_id") // Unique AWS SES Message ID per recipient
  opens       Int         @default(0)
  clicks      Int         @default(0)
  lastOpened  DateTime?   @map("last_opened")
  lastClicked DateTime?   @map("last_clicked")
  openedAt    DateTime?   @map("opened_at") // First open timestamp
  deliveredAt DateTime?   @map("delivered_at")
  sentAt      DateTime?   @map("sent_at") // When this recipient's email was sent
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  Email  Email        @relation(fields: [emailId], references: [id], onDelete: Cascade)
  events EmailEvent[]

  // Indexes for finding by messageId (AWS SNS events - now unique per recipient)
  @@index([messageId])
  @@index([emailId])
  @@map("email_recipients")
}

model Attachment {
  id        Int      @id @default(autoincrement())
  emailId   Int      @map("email_id")
  filename  String
  content   String? // Base64 encoded content (optional if path is provided)
  path      String? // URL to download attachment from
  type      String? // MIME type
  createdAt DateTime @default(now()) @map("created_at")

  Email Email @relation(fields: [emailId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

model EmailEvent {
  id               Int      @id @default(autoincrement())
  emailRecipientId Int      @map("email_recipient_id")
  type             String // delivered, opened, clicked, bounced, complained
  timestamp        DateTime @default(now())

  // Bounce/Complaint details
  bounceType            String? @map("bounce_type") // transient, permanent, undetermined
  bounceSubType         String? @map("bounce_sub_type") // MailboxFull, NoSuchUser, etc.
  complaintFeedbackType String? @map("complaint_feedback_type") // abuse, fraud, etc.

  userAgent String? @map("user_agent")
  ipAddress String? @map("ip_address")
  location  String?
  metadata  Json? // Additional event data

  EmailRecipient EmailRecipient @relation(fields: [emailRecipientId], references: [id], onDelete: Cascade)

  // Indexes for efficient querying
  @@index([type, timestamp])
  @@index([emailRecipientId])
  @@map("email_events")
}

// ============================================
// TEMPLATES
// ============================================

model Template {
  id           Int            @id @default(autoincrement())
  createdBy    Int?           @map("created_by") // User who created this template
  teamId       Int            @map("team_id") // Team that owns this template (personal or shared)
  name         String
  description  String?
  html         String
  subject      String?
  category     String? // transactional, marketing, etc.
  variables    String[]       @default([]) // Template variable names
  status       TemplateStatus @default(active)
  opens        Int            @default(0)
  clicks       Int            @default(0)
  createdAt    DateTime       @default(now()) @map("created_at")
  lastModified DateTime       @updatedAt @map("last_modified")

  Creator    User?       @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team       Team        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  broadcasts Broadcast[]

  @@map("templates")
}

// ============================================
// WEBHOOKS
// ============================================

model Webhook {
  id            Int           @id @default(autoincrement())
  createdBy     Int?          @map("created_by") // User who created this webhook
  teamId        Int           @map("team_id") // Team that owns this webhook (personal or shared)
  url           String
  events        String[] // Array of event types
  status        WebhookStatus @default(enabled)
  secret        String // Signing secret
  lastTriggered DateTime?     @map("last_triggered")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")

  Creator    User?             @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team       Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]

  @@map("webhooks")
}

model WebhookDelivery {
  id          Int                   @id @default(autoincrement())
  webhookId   Int                   @map("webhook_id")
  eventType   String                @map("event_type")
  messageId   String?               @map("message_id")
  status      WebhookDeliveryStatus
  request     Json // Request payload
  response    Json? // Response from webhook URL
  attempts    Int                   @default(1)
  createdAt   DateTime              @default(now()) @map("created_at")
  completedAt DateTime?             @map("completed_at")

  Webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@map("webhook_deliveries")
}

// ============================================
// API KEYS
// ============================================

model ApiKey {
  id         Int          @id @default(autoincrement())
  createdBy  Int          @map("created_by") // User who created this API key
  teamId     Int          @map("team_id") // Team that owns this API key (personal or shared)
  name       String
  key        String       @unique // The actual API key (hashed)
  permission String // Full access, Sending access, Read-only
  domain     String? // Specific domain or "All domains"
  status     ApiKeyStatus @default(active)
  lastUsed   DateTime?    @map("last_used")
  createdAt  DateTime     @default(now()) @map("created_at")

  Creator         User?            @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team            Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  apiRequestLogs  ApiRequestLog[]
  apiUsageMetrics ApiUsageMetric[]
  emails          Email[]

  @@map("api_keys")
}

// ============================================
// CONTACTS & AUDIENCES
// ============================================

model Contact {
  id           Int           @id @default(autoincrement())
  createdBy    Int?          @map("created_by") // User who created this contact
  teamId       Int           @map("team_id") // Team that owns this contact (personal or shared)
  email        String
  firstName    String?       @map("first_name")
  lastName     String?       @map("last_name")
  status       ContactStatus @default(subscribed)
  subscribedAt DateTime?     @map("subscribed_at")
  lastActivity DateTime?     @map("last_activity")
  tags         String[]      @default([])
  metadata     Json? // Additional custom fields
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")

  Creator             User?                @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team                Team                 @relation(fields: [teamId], references: [id], onDelete: Cascade)
  broadcastRecipients BroadcastRecipient[]
  audienceContacts    AudienceContact[]

  @@unique([teamId, email])
  @@map("contacts")
}

model Audience {
  id        Int      @id @default(autoincrement())
  reference String   @unique @default(cuid()) @map("reference") // UUID-like reference for API usage
  createdBy Int?     @map("created_by") // User who created this audience
  teamId    Int      @map("team_id") // Team that owns this audience (personal or shared)
  name      String
  type      String   @default("custom") // all, premium, custom, etc.
  filters   Json? // Filter criteria for dynamic audiences
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  Creator          User?             @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team             Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  audienceContacts AudienceContact[]
  broadcasts       Broadcast[]

  @@map("audiences")
}

model AudienceContact {
  id         Int      @id @default(autoincrement())
  audienceId Int      @map("audience_id")
  contactId  Int      @map("contact_id")
  createdAt  DateTime @default(now()) @map("created_at")

  Audience Audience @relation(fields: [audienceId], references: [id], onDelete: Cascade)
  Contact  Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([audienceId, contactId])
  @@map("audience_contacts")
}

// ============================================
// BROADCASTS
// ============================================

model Broadcast {
  id          Int             @id @default(autoincrement())
  createdBy   Int?            @map("created_by") // User who created this broadcast
  teamId      Int             @map("team_id") // Team that owns this broadcast (personal or shared)
  templateId  Int?            @map("template_id")
  audienceId  Int?            @map("audience_id") // Audience to send broadcast to
  name        String
  subject     String
  content     String? // HTML content if not using template
  status      BroadcastStatus @default(draft)
  totalSent   Int             @default(0) @map("total_sent")
  opens       Int             @default(0)
  clicks      Int             @default(0)
  scheduledAt DateTime?       @map("scheduled_at")
  sentAt      DateTime?       @map("sent_at")
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  Creator    User?                @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  Team       Team                 @relation(fields: [teamId], references: [id], onDelete: Cascade)
  Template   Template?            @relation(fields: [templateId], references: [id], onDelete: SetNull)
  Audience   Audience?            @relation(fields: [audienceId], references: [id], onDelete: SetNull)
  recipients BroadcastRecipient[]

  @@map("broadcasts")
}

model BroadcastRecipient {
  id          Int                      @id @default(autoincrement())
  broadcastId Int                      @map("broadcast_id")
  contactId   Int                      @map("contact_id")
  status      BroadcastRecipientStatus @default(pending)
  sentAt      DateTime?                @map("sent_at")
  openedAt    DateTime?                @map("opened_at")
  clickedAt   DateTime?                @map("clicked_at")

  Broadcast Broadcast @relation(fields: [broadcastId], references: [id], onDelete: Cascade)
  Contact   Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([broadcastId, contactId])
  @@map("broadcast_recipients")
}

// ============================================
// API REQUEST LOGS
// ============================================

model ApiRequestLog {
  id       String @id @default(cuid())
  teamId   Int    @map("team_id")
  apiKeyId Int?   @map("api_key_id")

  // Request details
  endpoint   String
  httpMethod String @map("http_method") // GET, POST, PUT, DELETE
  statusCode Int    @map("status_code") // HTTP response status

  // Performance metrics
  responseTime Int @map("response_time") // milliseconds

  // Request metadata
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")

  // Optional: Store request/response (can be expensive)
  requestBody  Json? @map("request_body")
  responseBody Json? @map("response_body")

  // Error tracking
  errorMessage String? @map("error_message") // Store error if request failed
  errorCode    String? @map("error_code") // Custom error code (e.g., RATE_LIMIT_EXCEEDED)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  Team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  ApiKey ApiKey? @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)

  // Indexes for common queries
  @@index([teamId, createdAt]) // Team dashboard analytics
  @@index([apiKeyId, createdAt]) // Per API key analytics
  @@index([createdAt]) // Time-based queries, cleanup
  @@index([statusCode]) // Error tracking
  @@map("api_request_logs")
}

// ============================================
// AGGREGATED ANALYTICS (OPTIONAL - RECOMMENDED)
// Store daily/hourly summaries to reduce log table size
// ============================================

model ApiUsageMetric {
  id       String @id @default(cuid())
  teamId   Int    @map("team_id")
  apiKeyId Int?   @map("api_key_id")

  // Time period
  date DateTime @db.Date
  hour Int? // 0-23, null for daily metrics

  // Aggregated metrics
  totalRequests      Int @default(0) @map("total_requests")
  successfulRequests Int @default(0) @map("successful_requests")
  failedRequests     Int @default(0) @map("failed_requests")

  // Status code breakdown
  status2xx Int @default(0) // 200-299
  status4xx Int @default(0) // 400-499
  status5xx Int @default(0) // 500-599

  // Performance
  avgResponseTime Int @default(0) @map("avg_response_time") // milliseconds

  // Endpoint breakdown (optional)
  endpointStats Json? @map("endpoint_stats") // { "/broadcasts": 100, "/emails": 50 }

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  Team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  ApiKey ApiKey? @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)

  // Unique constraint: one record per team/key per hour
  @@unique([teamId, apiKeyId, date, hour])
  @@index([teamId, date])
  @@index([apiKeyId, date])
  @@map("api_usage_metrics")
}

// ============================================
// EMAIL METRICS - Daily aggregated data
// ============================================
model EmailMetrics {
  id     String @id @default(cuid())
  teamId Int    @map("team_id")

  // Time period (daily)
  date DateTime @db.Date

  // Email counts
  sentCount       Int @default(0) @map("sent_count")
  deliveredCount  Int @default(0) @map("delivered_count")
  bouncedCount    Int @default(0) @map("bounced_count")
  complainedCount Int @default(0) @map("complained_count")

  // Bounce breakdown
  transientBounces    Int @default(0) @map("transient_bounces")
  permanentBounces    Int @default(0) @map("permanent_bounces")
  undeterminedBounces Int @default(0) @map("undetermined_bounces")

  // Calculated rates (stored as percentages * 100 for precision)
  deliverabilityRate Int @default(0) @map("deliverability_rate") // e.g., 9500 = 95.00%
  bounceRate         Int @default(0) @map("bounce_rate") // e.g., 250 = 2.50%
  complainRate       Int @default(0) @map("complain_rate") // e.g., 8 = 0.08%

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  Team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Unique constraint: one record per team per day
  @@unique([teamId, date])
  @@index([teamId, date])
  @@index([date])
  @@map("email_metrics")
}

// ============================================
// ROLES & PERMISSIONS
// ============================================

model Role {
  id          Int              @id @default(autoincrement())
  name        RoleName         @unique
  description String?
  permissions RolePermission[]
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  @@map("roles")
}

model Permission {
  id          Int              @id @default(autoincrement())
  name        PermissionName   @unique
  description String?
  roles       RolePermission[]
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  @@map("permissions")
}

model RolePermission {
  id           Int      @id @default(autoincrement())
  roleId       Int      @map("role_id")
  permissionId Int      @map("permission_id")
  createdAt    DateTime @default(now()) @map("created_at")

  Role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  Permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

// ============================================
// ENUMS
// ============================================

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
}

enum UserType {
  CUSTOMER
  ADMIN
  SUPER_ADMIN
}

enum VerificationRequestType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
}

enum MfaMethod {
  TOTP
  BACKUP_CODE
}

enum BlacklistType {
  EMAIL
  IP_ADDRESS
  DOMAIN
  USER_ID
}

enum OAuthProvider {
  GOOGLE
  GITHUB
}

enum BillingInterval {
  MONTHLY
  YEARLY
  LIFETIME
}

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELED
  UNPAID
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAUSED
}

enum RoleName {
  SUPER_ADMIN
  ADMIN
  MANAGER
  USER
  GUEST
}

enum PermissionName {
  // User Management
  USER_CREATE
  USER_READ
  USER_UPDATE
  USER_DELETE
  USER_LIST

  // Role Management
  ROLE_CREATE
  ROLE_READ
  ROLE_UPDATE
  ROLE_DELETE
  ROLE_LIST

  // Permission Management
  PERMISSION_CREATE
  PERMISSION_READ
  PERMISSION_UPDATE
  PERMISSION_DELETE
  PERMISSION_LIST

  // Domain Management
  DOMAIN_CREATE
  DOMAIN_READ
  DOMAIN_UPDATE
  DOMAIN_DELETE
  DOMAIN_LIST

  // Email Management
  EMAIL_CREATE
  EMAIL_READ
  EMAIL_UPDATE
  EMAIL_DELETE
  EMAIL_LIST
  EMAIL_SEND

  // Template Management
  TEMPLATE_CREATE
  TEMPLATE_READ
  TEMPLATE_UPDATE
  TEMPLATE_DELETE
  TEMPLATE_LIST

  // Webhook Management
  WEBHOOK_CREATE
  WEBHOOK_READ
  WEBHOOK_UPDATE
  WEBHOOK_DELETE
  WEBHOOK_LIST

  // Contact Management
  CONTACT_CREATE
  CONTACT_READ
  CONTACT_UPDATE
  CONTACT_DELETE
  CONTACT_LIST

  // Audience Management
  AUDIENCE_CREATE
  AUDIENCE_READ
  AUDIENCE_UPDATE
  AUDIENCE_DELETE
  AUDIENCE_LIST

  // Broadcast Management
  BROADCAST_CREATE
  BROADCAST_READ
  BROADCAST_UPDATE
  BROADCAST_DELETE
  BROADCAST_LIST
  BROADCAST_SEND

  // Analytics & Metrics
  METRICS_READ
  ANALYTICS_READ

  // System Administration
  SYSTEM_ADMIN
  SYSTEM_SETTINGS

  // Team Management
  TEAM_CREATE
  TEAM_READ
  TEAM_UPDATE
  TEAM_DELETE
  TEAM_LIST
  TEAM_MEMBER_INVITE
  TEAM_MEMBER_REMOVE
}

enum TeamInvitationStatus {
  pending
  accepted
  expired
  cancelled
}

enum DomainStatus {
  pending_dns // Waiting for DNS records to be added by user
  dns_verified // DNS records verified, ready for AWS registration
  pending_aws // Registered with AWS, waiting for AWS verification
  verified // Fully verified and ready to send emails
  failed // Verification failed
  revoked // Domain was transferred to another team
}

enum EmailStatus {
  queued
  sent
  delivered
  failed
  bounced
}

enum TemplateStatus {
  active
  archived
}

enum WebhookStatus {
  enabled
  disabled
}

enum WebhookDeliveryStatus {
  attempting
  success
  fail
}

enum ApiKeyStatus {
  active
  revoked
}

enum ContactStatus {
  subscribed
  unsubscribed
  bounced
}

enum BroadcastStatus {
  draft
  scheduled
  sending
  sent
  cancelled
}

enum BroadcastRecipientStatus {
  pending
  sent
  failed
  opened
  clicked
}

enum MfaVerificationSessionStatus {
  pending
  verified
  expired
  failed
}

enum TeamMemberRole {
  owner
  admin
  member
  viewer
}

enum NotificationType {
  domain_transfer // Domain was transferred to/from your team
  domain_verified // Domain verification successful
  domain_failed // Domain verification failed
  domain_dns_verified // DNS records verified
  domain_aws_pending // Domain registered with AWS, awaiting verification
  domain_deleted // Domain was deleted
  api_key_created // New API key created
  api_key_revoked // API key was revoked
  team_member_added // New team member added
  team_member_removed // Team member removed
  subscription_updated // Subscription plan changed
  subscription_expired // Subscription expired
  limit_reached // Usage limit reached (emails, domains, etc.)
  system_maintenance // System maintenance notification
}

enum NotificationSeverity {
  info // Informational notification
  success // Success notification (green)
  warning // Warning notification (yellow)
  error // Error notification (red)
}
